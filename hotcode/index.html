<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <!-- vuejs -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- unused -->
    <script src="https://unpkg.com/vue-router@4"></script>

    <!-- google fonts and icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Play&display=swap" rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />

    <!-- tooltip -->
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/scale.css" />


    <!-- alert -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/AlertifyJS/1.13.1/alertify.min.js"
        integrity="sha512-JnjG+Wt53GspUQXQhc+c4j8SBERsgJAoHeehagKHlxQN+MtCCmFDghX9/AcbkkNRZptyZU4zC8utK59M5L45Iw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/AlertifyJS/1.13.1/css/alertify.css"
        integrity="sha512-MpdEaY2YQ3EokN6lCD6bnWMl5Gwk7RjBbpKLovlrH6X+DRokrPRAF3zQJl1hZUiLXfo2e9MrOt+udOnHCAmi5w=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />

    <!-- css animations -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />

    <script src="../static/js/tree-sitter.js"></script>

    <script src="../monaco-editor/min/vs/loader.js"></script>
    <style>
        .center {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .full {
            width: 100%;
            height: 100%;
        }

        /* remove tailwind default */
        input[type="text"] {
            outline: none;
        }

        .tippy-box[data-theme~='transparent'] {
            background-color: #00000000;
        }

        /* width */
        ::-webkit-scrollbar {
            width: 10px;
        }

        /* Track */
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        /* Handle */
        ::-webkit-scrollbar-thumb {
            background: #888;
        }

        /* Handle on hover */
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .drag-handle-horizontal {
            cursor: col-resize;
            display: inline-block;
            width: auto;
            height: 100%;
            background-color: aqua;
            padding: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .drag-handle-horizontal::after {
            content: '';
            display: block;
            background-color: #555;
            width: 3px;
            height: 100%;
        }

        .drag-handle {
            cursor: row-resize;
            display: inline-block;
            height: auto;
            width: 100%;
            background-color: aqua;
            padding: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .drag-handle::after {
            content: '';
            display: block;
            background-color: #555;
            height: 3px;
            width: 100%;
        }

        .hover-effect {
            cursor: pointer;
            padding: 5px;
            color: #555;
        }

        .hover-effect:hover {
            color: #000;
            transition: 0.3s;
            cursor: pointer;
            background-color: #f1f1f1;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .output-message {
            margin: 1em;
            padding: 0.2em 0.5em 0.2em 0.5em;
            background-color: aqua;
            border-radius: 5px;
        }

        .vs-dark .output-message {
            background-color: #555;
        }

        .output-message2 {

            font-size: 0.8em;
            line-height: 0.8em;
            padding: 0em 0.4em 0em 0.4em;
            position: absolute;
            top: 70%;
            border: 1px solid white;

        }
    </style>
    <!-- fontawesome icon link -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">
    <script>
        tailwind.config = { darkMode: 'class' } // theme 
    </script>

</head>

<body class="flex flex-col h-screen bg-white dark:bg-zinc-950 text-zinc-950 dark:text-zinc-50">
    <script src="../static/js/dark-ssr.js"></script>

    <div class="w-full h-full flex flex-col   flex flex-col h-screen bg-white dark:bg-zinc-950 text-zinc-950 dark:text-zinc-50"
        id="app">
        <div
            class="topnav flex h-8 border-b dark:border-b dark:border-zinc-700 shrink-0 items-center px-6 py-2 space-x-2">
            <div class="grow"></div>
            <div class="run-button" onclick="runCurrentFile()">
                <i class="fa fa-play hover-effect "></i>
            </div>
            <div class="tailwind-dark-toggle"></div>
        </div>
        <div class="side-and-main flex flex-row grow overflow-auto relative grow">
            <div class="sidenav h-full bg-gray-300" style="width: 0%;">
            </div>
            <div class="drag-handle-horizontal" onmousedown="initDragHorizontal(event)">
            </div>
            <div class="main-content flex flex-col grow shrink-0 overflow-auto">
                <!-- main -->

                <div class="main bg-yellow-100 relative" style="height: 70%;">
                    <div class="editor full absolute overflow-hidden "></div>
                </div>
                <div class="drag-handle " onmousedown="initDrag(event)">
                    <!-- <div class="bg-red-500 full h-1"></div> -->
                </div>
                <div class="terminal w-full bg-zinc-900 grow relative">
                    <div class="output font-mono pre whitespace-pre-wrap full absolute  p-2 overflow-auto"></div>
                </div>

                <!-- /main -->
            </div>
        </div>
        <div class="  bottom flex h-8 grow-0 shrink-0  bg-zinc-100 dark:bg-zinc-900 border-t border-zinc-500">
        </div>
    </div>
    <script>

        let editor;
        let parser;
        let outputDecs = []
        let globalCompileTime = 0;

        function tryParseJSON(obj) {
            try {
                if (typeof obj == "string")
                    return JSON.stringify(obj);
            } catch (e) {
                return obj;
            }
        }
        alertify.set('notifier', 'position', 'bottom-center');
        let notify = (obj) => alertify.success(typeof obj == "string" ? obj : JSON.stringify(obj));

        (async () => {

            window.injectable = await (await fetch('/injectable.cpp')).text();
            window.placeholderCode = await (await fetch('/placeholderCode.cpp')).text();

            function asyncRequire(path) {
                return new Promise((resolve, reject) => {
                    require([path], resolve, reject);
                });
            }
            require.config({ paths: { vs: '../monaco-editor/min/vs' } });
            await asyncRequire('vs/editor/editor.main');
            editor = monaco.editor.create(document.querySelector('.editor'), {
                minimap: { enabled: false },
                value: window.placeholderCode,
                language: 'cpp',
            });
            monaco.editor.setTheme('vs-dark');
            function rsz() {
                editor.layout();
            }
            new ResizeObserver(rsz).observe(document.querySelector('.editor').parentElement)

            // on change set local storage
            editor.getModel().onDidChangeContent(() => {
                localStorage.lastCode = editor.getValue();
            });


            //set last text from llcal storage
            editor.setValue(localStorage.lastCode || window.placeholderCode);

            await TreeSitter.init();
            parser = new TreeSitter();
            const JavaScript = await TreeSitter.Language.load('../static/wasm/tree-sitter-cpp.wasm');
            parser.setLanguage(JavaScript);


            editor.getModel().onDidChangeContent(() => {
                runCurrentFile();
            });
            runCurrentFile();

        })();

        window.ontailwindthemechange = (theme) => {
            if (typeof monaco == 'undefined') return;
            if (theme == "dark") monaco.editor.setTheme('vs-dark');
            else monaco.editor.setTheme('vs');
        }


        async function runCurrentFile() {
            let code = editor.getValue();
            let tree = parser.parse(editor.getValue());
            let [syntaxTreeJSON, globalData] = syntaxNodeToJSON(tree.rootNode, { path: [] }, {});
            let replacedCode = injectable + '\n\n' + replaceExprs(
                code,
                globalData.functionCallSlices,
                globalData.binaryRights,
                globalData.identifiers,
            );

            console.log("text", replacedCode);



            clearOutput();
            editor.deltaDecorations(outputDecs, []);

            let res = await fetch('https://ab498.pythonanywhere.com/compile', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ code: replacedCode })
            });
            let data = await res.text();
            console.log(data);
            let lineOutputs = extractLineOutputs(data);
            let actualOutput = data.replace(/__res_start__(\d+)_(\d+)__[\s\S]*?__res_end__(\d+)_(\d+)__/g, "");

            addOutput(actualOutput);

            setOutputDecors(lineOutputs);
            return (data)
        }

        function addOutput(s) {
            document.querySelector(".output").textContent += s + "\n";
        }

        function clearOutput() {
            document.querySelector(".output").textContent = "";
        }


        function initDrag(e) {
            if (!elMap[event.currentTarget]) elMap[event.currentTarget] = {};
            elMap[event.currentTarget].dragStart = { x: event.pageX, y: event.pageY };
            elMap[event.currentTarget].parentEl = e.currentTarget.parentElement;
            elMap[event.currentTarget].beforeEl = e.currentTarget.previousSibling;
            elMap[event.currentTarget].afterEl = e.currentTarget.nextSibling;

            elMap[event.currentTarget].beforeElInitHeight = elMap[event.currentTarget].beforeEl.offsetHeight

            let tmp_func = (e) => resizeEl(e, event.currentTarget);
            elMap[event.currentTarget].parentEl.addEventListener('mousemove', tmp_func);
            elMap[event.currentTarget].parentEl.addEventListener('mouseup', (e) => {
                elMap[event.currentTarget].parentEl.removeEventListener('mousemove', tmp_func);
            });
        }
        function initDragHorizontal(e) {
            if (!elMap[event.currentTarget]) elMap[event.currentTarget] = {};
            elMap[event.currentTarget].dragStart = { x: event.pageX, y: event.pageY };
            elMap[event.currentTarget].parentEl = e.currentTarget.parentElement;
            elMap[event.currentTarget].beforeEl = e.currentTarget.previousSibling;
            elMap[event.currentTarget].afterEl = e.currentTarget.nextSibling;

            elMap[event.currentTarget].beforeElInitWidth = elMap[event.currentTarget].beforeEl.offsetWidth

            let tmp_func = (e) => resizeElHorizontal(e, event.currentTarget);
            elMap[event.currentTarget].parentEl.addEventListener('mousemove', tmp_func);
            elMap[event.currentTarget].parentEl.addEventListener('mouseup', (e) => {
                elMap[event.currentTarget].parentEl.removeEventListener('mousemove', tmp_func);
            })
        }
        function clamp(x, a, b) {
            return Math.min(Math.max(x, a), b)
        }
        const elMap = {}
        function resizeEl(e, target) {
            let dragLength = e.clientY - elMap[e.currentTarget].dragStart.y

            elMap[target].beforeEl.style.height = elMap[target].beforeElInitHeight + dragLength + "px";
        }
        function resizeElHorizontal(e, target) {
            let dragLength = e.clientX - elMap[e.currentTarget].dragStart.x

            elMap[target].beforeEl.style.width = elMap[target].beforeElInitWidth + dragLength + "px";
        }
        const { createApp, ref, onMounted } = Vue

        const app = createApp({
            setup() {
                const loaded = ref(false);
                const user = ref({
                    firstName: 'Zubaer',
                    lastName: 'Ahmed',
                    email: 'zubaerahmed100@gmail.com',
                    phone: '+8801827829617',
                    address: 'ECB, Dhaka Cantonment',
                    postcode: '1206',
                    avatar: 'https://picsum.photos/200/300'
                })
                const sidebarWindow = ref('/profile')
                const lefnavItems = ref([{
                    name: 'User Info',
                    icon: 'person',
                    path: '/profile'
                }, {
                    name: 'Favourites',
                    icon: 'favorite',
                    path: '/favourites'
                }, {
                    name: 'Watchlist',
                    icon: 'star',
                    path: '/watchlist'
                },
                {
                    name: 'Settings',
                    icon: 'settings',
                    path: '/settings'
                },
                {
                    name: 'Notifiations',
                    icon: 'notifications',
                    path: '/notifications'
                },
                ])
                const breakpoint = ref([]);
                const getBP = () => {
                    const width = window.innerWidth;
                    if (width >= 1536) return ['2xl', 'xl', 'lg', 'md', 'sm']
                    if (width >= 1280) return ['xl', 'lg', 'md', 'sm']
                    if (width >= 1024) return ['lg', 'md', 'sm']
                    if (width >= 768) return ['md', 'sm'];
                    if (width >= 640) return ['sm'];
                    return 'default'; // or handle differently
                };
                onMounted(() => {
                    setTimeout(() => {
                        loaded.value = true;
                    }, 0);
                    window.addEventListener('resize', () => { breakpoint.value = getBP() });
                    breakpoint.value = getBP();
                })
                return {
                    lefnavItems,
                    sidebarWindow,
                    user,
                    loaded,
                    breakpoint
                }
            }

        });
        app.config.globalProperties.window = window;
        app.mount('#app')
        const template = document.querySelector('.expanded-profile');
        // template.classList.remove('hidden');



        function syntaxNodeToJSON(node, parent, globalData) {
            const jsonNode = {
                type: node.type,
                text: node.text,
                path: [...parent.path, node.type],
                children: [],
            };

            for (let i = 0; i < node.childCount; i++) {
                const child = node.child(i);
                jsonNode.children.push(
                    syntaxNodeToJSON(child, jsonNode, globalData)[0]
                );
            }
            globalData.functionToReturnMap = globalData.functionToReturnMap || {};
            globalData.functionCallSlices = globalData.functionCallSlices || [];
            globalData.binaryRights = globalData.binaryRights || [];
            globalData.identifiers = globalData.identifiers || [];
            found = true;
            ["function_definition"].forEach((element, idx) => {
                if (jsonNode.path.slice(-1)[idx] == element) {
                } else found = false;
            });
            if (found) {
                let func_name = jsonNode.children
                    .find((e) => e.type == "function_declarator")
                    ?.children.find((e) =>
                        ["identifier", "field_identifier"].includes(e.type)
                    )?.text;
                let ret_type = jsonNode.children.find((e) =>
                    [
                        "primitive_type",
                        "qualified_identifier",
                        "template_type",
                    ].includes(e.type)
                )?.text;
                globalData.functionToReturnMap[func_name] = ret_type;
            }
            // identifier
            found = true;
            ["expression_statement", "identifier"].forEach((element, idx) => {
                if (jsonNode.path.slice(-2)[idx] == element) {
                } else found = false;
            });
            if (found) {
                globalData.identifiers.push(node);
            }
            // call
            found = true;
            ["expression_statement", "call_expression"].forEach((element, idx) => {
                if (jsonNode.path.slice(-2)[idx] == element) {
                } else found = false;
            });
            if (found) {
                let callexpr = node;
                if (
                    [
                        ...Object.entries(globalData.functionToReturnMap).filter(
                            (el) => el[1] != "void"
                        ),
                        ["printf", "int"],
                    ].some((el) =>
                        [
                            callexpr.children.find((e) =>
                                ["identifier", "field_identifier"].includes(e.type)
                            )?.text,
                            callexpr.children
                                .find((e) => ["field_expression"].includes(e.type))
                                ?.children.find((e) => ["field_identifier"].includes(e.type))
                                ?.text,
                        ].includes(el[0])
                    )
                )
                    globalData.functionCallSlices.push(callexpr);
                // console.log(globalData.functionToReturnMap, 'callexpr', callexpr
                //     .children.find(e => ['field_expression'].includes(e.type))
                //     ?.children.find(e => ['field_identifier'].includes(e.type))?.text)
            }

            found = true;
            ["assignment_expression"].forEach((element, idx) => {
                if (jsonNode.path.slice(-1)[idx] == element) {
                } else found = false;
            });
            if (found) {
                let operand = node.children.find((e) => e.type == "<<")?.text;
                let right = node.childForFieldName("right");
                // console.log('assignment', node, right);
                // console.log('assignment_expression', node.childForFieldName("right").walk().nodeType, node.childForFieldName("right").walk().nodeText)
                if (
                    right.text != "endl" &&
                    right.text != "std::endl" &&
                    operand == "<<"
                )
                    globalData.binaryRights.push(right);
            }
            found = true;
            ["binary_expression"].forEach((element, idx) => {
                if (jsonNode.path.slice(-1)[idx] == element) {
                } else found = false;
            });
            if (found) {
                let operand = node.children.find((e) => e.type == "<<")?.text;
                let right = node.childForFieldName("right");
                // console.log(operand, 'right', right.text);
                if (
                    right.text != "endl" &&
                    right.text != "std::endl" &&
                    operand == "<<"
                )
                    globalData.binaryRights.push(right);
            }
            globalData.binaryRights.forEach((e) => {
                e.isBin = true;
            });
            return [jsonNode, globalData];
        }

        function replaceExprs(s, callNodes, binaryNodes, identifiers) {
            let mergedNodes = [...callNodes, ...binaryNodes, ...identifiers].sort((a, b) => {
                return a.startIndex - b.startIndex;
            });
            mergedNodes.reverse().forEach((node) => {
                if (node.isBin) {
                    // console.log('node', node.children);
                    let prefix = s.substring(0, node.startIndex);
                    let postfix = s.substring(node.endIndex, s.length);
                    let replace = s.substring(node.startIndex, node.endIndex);
                    // console.log('replace', replace);
                    s =
                        prefix +
                        `_conv_string(${replace}, ${node.startIndex}, ${node.endIndex})` +
                        postfix;
                    return;
                }

                let func_name = node.children.find((e) =>
                    ["identifier", "field_identifier"].includes(e.type)
                )?.text;
                let args = node.children.find((e) =>
                    ["argument_list"].includes(e.type)
                )?.text;
                let prefix = s.substring(0, node.startIndex);
                let postfix = s.substring(node.endIndex, s.length);
                let replace = s.substring(node.startIndex, node.endIndex);
                // console.log('replace_func', replace);
                if (func_name == "printf") {
                    s =
                        prefix +
                        `_special_printf(${node.startIndex}, ${node.endIndex}, ${args.slice(
                            1,
                            args.length - 1
                        )})` +
                        postfix;
                } else
                    s =
                        prefix +
                        `_conv_string(${replace}, ${node.startIndex}, ${node.endIndex})` +
                        postfix;
            });
            return s;
        }
        function extractLineOutputs(outputString) {
            let matches = findRegexMatches(
                outputString,
                /__res_start__(\d+)_(\d+)__[\s\S]*?__res_end__(\d+)_(\d+)__/gs
            );
            let lineOutputs = {};
            matches.forEach((match) => {
                let prefix = match.match(/__res_start__(\d+)_(\d+)__/);
                let lineNum = prefix[1];
                let col = prefix[2];
                let suffix = match.match(/__res_end__(\d+)_(\d+)__/)[1];
                let line = match.match(
                    /__res_start__(\d+)_(\d+)__([\s\S]*?)__res_end__(\d+)_(\d+)__/s
                )[3];
                lineOutputs[lineNum + "_" + col] =
                    (lineOutputs[lineNum + "_" + col]
                        ? lineOutputs[lineNum + "_" + col] + "\n"
                        : "") + line.trim();
            });
            return lineOutputs;
        }

        function findRegexMatches(string, regex) {
            let matches = [];
            let match;
            while ((match = regex.exec(string))) {
                matches.push(match[0]);
            }
            return matches;
        }
        function setOutputDecors(lineOutputs, code) {
            // Clear existing decorations
            hoverDecs = editor.deltaDecorations(outputDecs, []);
            outputDecs = [];

            for (const [key, value] of Object.entries(lineOutputs)) {
                const startPosition = editor.getModel().getPositionAt(parseInt(key.split("_")[0]));
                const lastCharIndex = editor.getModel().getLineContent(startPosition.lineNumber).length - 1;
                console.log(lastCharIndex);
                const endPosition = editor.getModel().getPositionAt(parseInt(key.split('_')[1]));

                const range = new monaco.Range(startPosition.lineNumber, lastCharIndex + 1, endPosition.lineNumber, lastCharIndex + 20);

                let message = value.length > 50 ? value.slice(0, 50) + "..." : value;
                outputDecs = outputDecs.concat(editor.deltaDecorations([], [
                    {
                        range,
                        options: {
                            hoverMessage: [{
                                isTrusted: true,
                                supportHtml: true,
                                value: `<pre style="color:#ff0000;">${value}</pre>`
                            }],
                            after: message ? {
                                content: message.replace(/\r*\n/g, ' '),
                                inlineClassName: 'output-message text-yellow-500',
                                inlineClassNameAffectsLetterSpacing: true,
                            } : undefined,
                        },
                    },
                ]));
            }

        }

    </script>
</body>

</html>