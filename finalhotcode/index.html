<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <script type="text/javascript" src="http://code.jquery.com/jquery-1.11.1.min.js">
    </script>
    <script type="text/javascript" src="https://golden-layout.com/files/latest/js/goldenlayout.min.js"></script>
    <link type="text/css" rel="stylesheet" href="https://golden-layout.com/files/latest/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://golden-layout.com/files/latest/css/goldenlayout-dark-theme.css" />


    <script src="https://cdn.tailwindcss.com"></script>
    <script src="../static/js/utils.js"></script>

    <script src="initTerminal.js"></script>
    <script src="initLayout.js"></script>


    <script src="https://cdn.jsdelivr.net/npm/xterm@5.2.1/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@4.19.0/css/xterm.css" />
    <script src="monaco-editor/min/vs/loader.js"></script>


    <script src="../wasm-clang/shared.js"></script>
    <script src="../wasm-clang/shared_web.js"></script>
    <script src="../static/js/tree-sitter.js"></script>


    <link rel="stylesheet" href="../static/css/style.css">
</head>

<body class="w-screen h-screen">
    <div class="terminal w-full h-full"></div>
    <div class="editor w-full h-full"></div>
    <div id="wrapper" class="w-full h-full flex flex-col">
        <ul id="menuContainer" class="w-full h-12 bg-blue-500"></ul>
        <div id="layoutContainer" class="w-full grow "></div>
    </div>
    <script>


        (async () => {

            await window.initLayout();
            window.injectable = await (await fetch('injectable.cpp')).text();
            window.placeholderCode = await (await fetch('placeholderCode.cpp')).text();

            function asyncRequire(path) {
                return new Promise((resolve, reject) => {
                    require([path], resolve, reject);
                });
            }
            require.config({ paths: { vs: 'monaco-editor/min/vs' } });
            await asyncRequire('vs/editor/editor.main');
            window.editor = monaco.editor.create(document.querySelector('.editor'), {
                minimap: { enabled: false },
                value: window.placeholderCode,
                language: 'cpp',
            });
            window.decorations = [];
            window.decorationIds = window.editor.deltaDecorations([], []);
            window.hoverDecs = window.editor.deltaDecorations([], []);
            window.outputDecs = window.editor.deltaDecorations([], []);
            monaco.editor.setTheme('vs-dark');

            await initTerminal();

            window.addEventListener("resize", () => {
                window.myLayout.updateSize(); // Resize the entire layout
            });
            await TreeSitter.init();
            window.window.parser = new TreeSitter();
            const JavaScript = await TreeSitter.Language.load('../static/wasm/tree-sitter-cpp.wasm');
            window.parser.setLanguage(JavaScript);
            await window.runCode(window.editor, window.parser)
            window.editor.getModel().onDidChangeContent((event) => {
                window.runCode(window.editor, window.parser)
            });

        })().catch(console.error);


        window.runCode = async () => {
            debug("Compiling and running ...");
            let code = window.editor.getValue();
            const tree = window.parser.parse(code);
            window.hoverDecs = window.editor.deltaDecorations(window.hoverDecs, []);
            let list = (await traverseTree(tree, [['function_definition', 'primitive_type']]));
            // decorationIds = editor.deltaDecorations(decorationIds, []);
            colorCode(editor, list);
            // replacedCode = getReplacedCode(code, list);
            // let outputString;
            // try {
            //     outputString = (await api.compileLinkRun(replacedCode));
            // } catch (e) {
            //     outputString = e;
            //     window.term.write('\n' + outputString + '\n');
            //     window.term.write('\n\x1B[1;3;31m >> \x1B[0m');
            //     debug(e);
            // }
            // let lineOutputs = (extractLineOutputs(outputString)); // {}
            // window.outputDecs = editor.deltaDecorations(window.outputDecs, []);
            // addOutputDecors(lineOutputs, code);
            const syntaxTreeJSON = syntaxNodeToJSON(tree.rootNode, { path: [] });
            // console.log(syntaxTreeJSON)
        }
        function syntaxNodeToJSON(node, parent) {
            const jsonNode = {
                type: node.type,
                text: node.text,
                path: [...parent.path, node.type],
                children: [],
            };

            for (let i = 0; i < node.childCount; i++) {
                const child = node.child(i);
                jsonNode.children.push(syntaxNodeToJSON(child, jsonNode));
            }
            found = true;
            ['function_definition', 'primitive_type'].forEach((element, idx) => {
                // recusive json tree.func_name
                if (jsonNode.path.slice(-2)[idx] == element) {
                } else
                    found = false;
            });
            if (found)
                console.log(jsonNode.path)

            return jsonNode;
        }

        function colorCode(editor, list) {
            for (let i = 0; i < list.length; i++) {
                // debug(...[list[i][0], list[i][1], list[i][2], list[i][3]]);
                window.decorationIds = [...window.decorationIds, window.editor.deltaDecorations([], [{
                    range: {
                        startLineNumber: list[i][0] + 1,
                        startColumn: list[i][1] + 1,
                        endLineNumber: list[i][2] + 1,
                        endColumn: list[i][3] + 1
                    },
                    options: {
                        isWholeLine: false,
                        inlineClassName: 'bg-red-700 bg-opacity-50',
                        inlineClassNameAffectsLetterSpacing: true,
                    }
                }])]
            }
            // var decorationsInRange = window.editor.getModel().getDecorationsInRange({
            //     startLineNumber: list[i][0] + 1,
            //     startColumn: list[i][1] + 1,
            //     endLineNumber: list[i][2] + 1,
            //     endColumn: list[i][3] + 1
            // });
            //  console.log(decorationsInRange);
            // window.hoverDecs = window.editor.deltaDecorations(decorationsInRange, []);
        }

        async function traverseTree(tree, matchMap) {
            const catupreList = [];
            const cursor = tree.walk();
            let finishedRow = false;
            let visitedChildren = false;
            let indentLevel = 0;
            let curr_path = [];

            for (let i = 0; ; i++) {
                if (i > 0 && i % 10000 === 0) {
                    await new Promise(r => setTimeout(r, 0));
                }
                const start = cursor.startPosition;
                const end = cursor.endPosition;

                let displayName;
                if (cursor.nodeIsMissing) {
                    displayName = `MISSING ${cursor.nodeType}`
                } else if (cursor.nodeIsNamed) {
                    displayName = cursor.nodeType;
                }
                if (visitedChildren) {
                    if (displayName) {
                        finishedRow = true;
                    }
                    if (cursor.gotoNextSibling()) {
                        curr_path.pop();
                        visitedChildren = false;

                        curr_path.push(displayName)
                        indentLevel++;
                        let code = window.editor.getValue();
                        let lines = code.split('\n');
                        let text = (start.row != end.row ? [
                            lines[start.row].substring(start.column),
                            ...lines.slice(start.row + 1, end.row - 1),
                            lines[end.row].substring(0, end.column)
                        ] :
                            [lines[start.row].substring(start.column, end.column)]
                        ).join('\n');
                        if (indentLevel > 0) {
                            // console.log(text, curr_path)
                        }
                        let found = true;
                        matchMap.forEach((targetPath, idx) => {
                            targetPath.forEach((element, idx) => {
                                if (curr_path.slice(-targetPath.length)[idx] == element) {
                                } else
                                    found = false;
                            });
                        });
                        // ['function_definition'].forEach((element, idx) => {
                        //     if (curr_path.slice(-1)[idx] == element) {
                        //         console.log(traverseTree(cursor.getNode(), ['primitive_type']));
                        //     }
                        // });

                        if (found) {
                            if (!catupreList.find(a => a[0] === start.row && a[1] === start.column
                            )) {
                                catupreList.push([start.row, start.column, end.row, end.column, displayName]);
                            }
                        }
                    } else if (cursor.gotoParent()) {
                        visitedChildren = true;
                        indentLevel--;
                        curr_path.pop();
                    } else {
                        break;
                    }
                } else {

                    if (displayName) {
                        if (finishedRow) {
                            finishedRow = false;
                        }
                        const id = cursor.nodeId;
                        let fieldName = cursor.currentFieldName();
                        if (fieldName) {
                            fieldName += ': ';
                        } else {
                            fieldName = '';
                        }
                        // if (displayName === 'call_expression') {
                        //     // let org = cursor.currentNode();
                        //     // const newcursor = {...cursor};
                        //     // newcursor.reset(org);
                        //     // newcursor.gotoParent();
                        //     // cursor.gotoParent();
                        //     // let parentDisplayName = newcursor.nodeType;
                        //     // debug(cursor, newcursor);
                        //     // cursor.reset(org); 
                        //     if (!catupreList.find(a => a[0] === start.row && a[1] === start.column
                        //     )) {
                        //         catupreList.push([start.row, start.column, end.row, end.column, fieldName, displayName, id]);
                        //     }
                        // }

                        // createDecor([[start.row + 1, start.column + 1], [end.row + 1, end.column + 1]], displayName)
                        // console.log(displayName, start, end, id);
                        addHoverMessage([start.row, start.column, end.row, end.column], displayName);
                        finishedRow = true;
                    }

                    if (cursor.gotoFirstChild()) {
                        visitedChildren = false;
                        curr_path.push(displayName)
                        indentLevel++;
                        let code = window.editor.getValue();
                        let lines = code.split('\n');
                        let text = (start.row != end.row ? [
                            lines[start.row].substring(start.column),
                            ...lines.slice(start.row + 1, end.row - 1),
                            lines[end.row].substring(0, end.column)
                        ] :
                            [lines[start.row].substring(start.column, end.column)]
                        ).join('\n');
                        if (indentLevel > 0) {
                            // console.log(text, curr_path)
                        }
                        let found = true;
                        matchMap.forEach((targetPath, idx) => {
                            targetPath.forEach((element, idx) => {
                                if (curr_path.slice(-targetPath.length)[idx] == element) {
                                } else
                                    found = false;
                            });
                        });
                        if (found) {
                            if (!catupreList.find(a => a[0] === start.row && a[1] === start.column
                            )) {
                                catupreList.push([start.row, start.column, end.row, end.column, displayName]);
                            }
                        }
                    } else {
                        visitedChildren = true;
                    }
                }

            }
            if (finishedRow) {
            }


            cursor.delete();

            return catupreList;
        }

        function addHoverMessage(line, message) {

            window.hoverDecs = [...window.hoverDecs, window.editor.deltaDecorations([], [{
                range: {
                    startLineNumber: line[0] + 1,
                    startColumn: line[1] + 1,
                    endLineNumber: line[2] + 1,
                    endColumn: line[3] + 1
                },
                options: {
                    isWholeLine: false,
                    hoverMessage: message ? {
                        value: message,
                    } : undefined,
                }
            }])]
        }
    </script>
</body>

</html>