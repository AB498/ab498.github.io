<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="../static/js/utils.js"></script>
    <script src="../wasm-clang/shared.js"></script>
    <script src="../wasm-clang/shared_web.js"></script>
    <script src="../static/js/tree-sitter.js"></script>
    <link rel="stylesheet" href="../static/css/style.css">
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.11.1.min.js">
    </script>
    <script type="text/javascript" src="https://golden-layout.com/files/latest/js/goldenlayout.min.js"></script>
    <link type="text/css" rel="stylesheet" href="https://golden-layout.com/files/latest/css/goldenlayout-base.css" />
    <link type="text/css" rel="stylesheet"
        href="https://golden-layout.com/files/latest/css/goldenlayout-dark-theme.css" />
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0" />
    <style>
        .info-plate {
            font-size: 0.7em;
            line-height: 0.8em;
            position: absolute;
            top: 70%;
            border: 1px solid white;
        }
    </style>
</head>

<body class="w-screen h-screen flex flex-col">

    <div class="flex px-1 space-x-2 shadow-md">
        <div class="px-2 hover-effect">File</div>
        <div class="px-2 hover-effect">Edit</div>
        <div class="px-2 hover-effect">Run</div>
        <div class="px-2 hover-effect">Tools</div>
    </div>
    <div class="full flex">
        <div class="flex flex-col w-12 shrink-0 bg-red-500 items-center ">
            <div class="px-2 hover-effect">
                <span class="material-symbols-outlined text-white text-2xl">
                    menu
                </span>
            </div>
        </div>
        <div class="flex grow bg-zinc-800 shrink-0 ">
            <!-- Use relative and absolute positioning to avoid child affecting parent's size -->
            <div class="relative basis-full sm:basis-3/6 shrink-0">
                <div class="absolute editor full">
                </div>
            </div>
            <div class="flex flex-col  w-0 sm:basis-3/6 shrink-0">
                <div
                    class="terminal font-mono whitespace-pre-wrap overflow-auto  flex h-1/2 bg-blue-500 sm:translate-x-0 translate-x-full">
                </div>
                <div class="flex h-1/2 bg-green-500 sm:translate-x-0 translate-x-full">
                </div>
            </div>
        </div>
    </div>
    <script src="monaco-editor/min/vs/loader.js"></script>
    <script>

        function asyncRequire(path) {
            return new Promise((resolve, reject) => {
                require([path], resolve, reject);
            });
        }


        (async () => {
            require.config({paths: {vs: 'monaco-editor/min/vs'}});
            await asyncRequire('vs/editor/editor.main');
            window.editor = monaco.editor.create(document.querySelector('.editor'), {
                value:
                    `#include <iostream>\nusing namespace std;
int hello(){\n    return 1;\n}
int main() {\n    hello();\n    int a = 4 - hello();
    cout << "Hello World!";\n    return 0;\n}`,
                language: 'cpp',
            });
            window.decorations = [];
            window.decorationIds = editor.deltaDecorations([], []);
            window.hoverDecs = editor.deltaDecorations([], []);

            //theme
            monaco.editor.setTheme('vs-dark');
            window.addEventListener('resize', () => {
                editor.layout();
            });
            await TreeSitter.init();
            let parser = new TreeSitter();
            const JavaScript = await TreeSitter.Language.load('../static/wasm/tree-sitter-cpp.wasm');
            parser.setLanguage(JavaScript);
            runCode(editor, parser)
            editor.getModel().onDidChangeContent((event) => {
                runCode(editor, parser);
            });
        })().catch(console.error);

        function findDecoration(startRow, startColumn, endRow, endColumn) {
            for (let i = 0; i < decorations.length; i++) {
                const decoration = decorations[i];
                if (decoration.startRow === startRow &&
                    decoration.startColumn === startColumn &&
                    decoration.endRow === endRow &&
                    decoration.endColumn === endColumn) {
                    return decoration;
                }
            }
            return null;
        }
        async function runCode(editor, parser) {
            let code = editor.getValue();
            const tree = parser.parse(code);
            let list = (await renderTree(tree));
            // debug(list);
            colorCode(editor, list);
            code = getReplacedCode(code, list);
            document.querySelector(".terminal").textContent = code;
            console.log(await api.compileLinkRun(code));
            const syntaxTreeJSON = syntaxNodeToJSON(tree.rootNode);
            debug(syntaxTreeJSON)
        }

        function syntaxNodeToJSON(node) {
            const jsonNode = {
                type: node.type,
                text: node.text,
                children: [],
            };

            for (let i = 0; i < node.childCount; i++) {
                const child = node.child(i);
                jsonNode.children.push(syntaxNodeToJSON(child));
            }

            return jsonNode;
        }
        function getReplacedCode(code, list) {
            let newCode = code;
            let lines = code.split('\n');
            for (let i = 0; i < 1; i++) {
                let start = list[i][0];
                let end = list[i][2];
                let startColumn = list[i][1];
                let endColumn = list[i][3];
                let replace = lines[start].substring(startColumn, endColumn)
                lines[start] = lines[start].replace(replace, `ConvToString(${replace})`);

            }
            let injectable =
                `
#include <sstream>
#include <string>
#include <vector>
#include <map>
#include <iostream>
#include <memory>
#include <stdexcept>

template <typename T>
std::string ConvToString(const T &value)
{
  std::cout << "_res_";
  std::ostringstream os;
  os << value;
  return os.str();
}

template <typename T>
std::string ConvToString(const std::vector<T> &vec)
{
  std::ostringstream os;
  os << "[";
  for (size_t i = 0; i < vec.size(); ++i)
  {
    if (i > 0)
      os << ", ";
    os << ConvToString(vec[i]);
  }
  os << "]";
  return os.str();
}

template <typename K, typename V>
std::string ConvToString(const std::map<K, V> &map)
{
  std::ostringstream os;
  os << "{";
  for (auto it = map.begin(); it != map.end(); ++it)
  {
    if (it != map.begin())
      os << ", ";
    os << ConvToString(it->first) << ": " << ConvToString(it->second);
  }
  os << "}";
  return os.str();
}

template <typename T>
std::string ConvToString(const T *arr, size_t N)
{
  std::ostringstream os;
  os << "[";
  for (size_t i = 0; i < N; ++i)
  {
    if (i > 0)
      os << ", ";
    os << ConvToString(arr[i]);
  }
  os << "]";
  return os.str();
}

template <typename T, size_t N>
std::string ConvToString(const T (&arr)[N])
{
  std::ostringstream os;
  os << "[";
  for (size_t i = 0; i < N; i++)
  {
    os << ConvToString(arr[i]);
    if (i != N - 1)
      os << ", ";
  }
  os << "]";
  return os.str();
}
std::string ConvToString(const char *value)
{
  return std::string(value);
}

	`;
            return injectable + '\n' + lines.join('\n');
        }
        function addHoverMessage(line, message) {
            window.hoverDecs = editor.deltaDecorations([
                ...editor.getModel().getDecorationsInRange({
                    startLineNumber: line[0] + 1,
                    startColumn: line[1] + 1,
                    endLineNumber: line[2] + 1,
                    endColumn: line[3] + 1
                })
            ], []);
            window.hoverDecs = [...window.hoverDecs, editor.deltaDecorations([], [{
                range: {
                    startLineNumber: line[0] + 1,
                    startColumn: line[1] + 1,
                    endLineNumber: line[2] + 1,
                    endColumn: line[3] + 1
                },
                options: {
                    isWholeLine: false,
                    hoverMessage: message ? {
                        value: message,
                    } : undefined,
                    // after: message ? {
                    //     content: message,
                    //     inlineClassName: 'bg-blue-700 info-plate',
                    // } : undefined
                }
            }])]
        }
        function colorCode(editor, list) {
            decorationIds = editor.deltaDecorations(decorationIds, []);
            for (let i = 0; i < list.length; i++) {
                // debug(...[list[i][0], list[i][1], list[i][2], list[i][3]]);
                window.decorationIds = [...window.decorationIds, editor.deltaDecorations([], [{
                    range: {
                        startLineNumber: list[i][0] + 1,
                        startColumn: list[i][1] + 1,
                        endLineNumber: list[i][2] + 1,
                        endColumn: list[i][3] + 1
                    },
                    options: {
                        isWholeLine: false,
                        inlineClassName: 'bg-red-700',
                    }
                }])]
            }
        }

        async function renderTree(tree) {
            const catupreList = [];
            const cursor = tree.walk();
            let finishedRow = false;
            let visitedChildren = false;
            let indentLevel = 0;
            for (let i = 0; ; i++) {
                if (i > 0 && i % 10000 === 0) {
                    await new Promise(r => setTimeout(r, 0));
                }

                let displayName;
                if (cursor.nodeIsMissing) {
                    displayName = `MISSING ${cursor.nodeType}`
                } else if (cursor.nodeIsNamed) {
                    displayName = cursor.nodeType;
                }

                if (visitedChildren) {
                    if (displayName) {
                        finishedRow = true;
                    }
                    if (cursor.gotoNextSibling()) {
                        visitedChildren = false;
                    } else if (cursor.gotoParent()) {
                        visitedChildren = true;
                        indentLevel--;
                    } else {
                        break;
                    }
                } else {
                    if (displayName) {
                        if (finishedRow) {
                            finishedRow = false;
                        }
                        const start = cursor.startPosition;
                        const end = cursor.endPosition;
                        const id = cursor.nodeId;
                        let fieldName = cursor.currentFieldName();
                        if (fieldName) {
                            fieldName += ': ';
                        } else {
                            fieldName = '';
                        }
                        if (displayName === 'call_expression') {
                            // let org = cursor.currentNode();
                            // const newcursor = {...cursor};
                            // newcursor.reset(org);
                            // newcursor.gotoParent();
                            // cursor.gotoParent();
                            // let parentDisplayName = newcursor.nodeType;
                            // debug(cursor, newcursor);
                            // cursor.reset(org); 
                            catupreList.push([start.row, start.column, end.row, end.column, fieldName, displayName, id]);

                        }
                        // createDecor([[start.row + 1, start.column + 1], [end.row + 1, end.column + 1]], displayName)
                        // console.log(displayName, start, end, id);
                        addHoverMessage([start.row, start.column, end.row, end.column], displayName);
                        finishedRow = true;
                    }

                    if (cursor.gotoFirstChild()) {
                        visitedChildren = false;
                        indentLevel++;
                    } else {
                        visitedChildren = true;
                    }
                }
            }
            if (finishedRow) {
            }

            cursor.delete();

            return catupreList;
        }



    </script>
</body>

</html>